#! /usr/bin/ruby

# Sebastien Delafond <seb@untangle.com>

require 'optparse'
require 'log4r'
require 'untangle-reprepro.rb'

TOP_LEVEL_DIR = "/var/www/public"
INCOMING_DIR = "/var/www/untangle/incoming"
LOGFILE = "/var/log/untangle-incoming-queue-daemon.log"
DELAY = 60

def initializeLogging(logToFileOnly, verbose)
  log = Log4r::Logger.new("Untangle Incoming Queue Daemon")

  if logToFileOnly then
    fileFormat = Log4r::PatternFormatter.new(:pattern => "[ %d ] %l\t %m")
    log.add(Log4r::FileOutputter.new("fileOutputter", :filename => LOGFILE,
                                     :trunc => false, :formatter => fileFormat))
  else
    stdoutFormat = Log4r::PatternFormatter.new(:pattern => "%l:\t %m")
    log.add(Log4r::StdoutOutputter.new('stdout', :formatter => stdoutFormat))
  end

  log.level = verbose ? Log4r::DEBUG : Log4r::INFO
  
  return log
end

def processChangeFile(changeFile, repositories, options)
  cfu = ChangeFileUpload.new(changeFile, options[:moveFiles])
  processDebianUpload(cfu, repositories, options)
end

def processManifestFile(manifestFile, repositories, options)
  pu = PackageUpload.new(manifestFile, options[:moveFiles])
  processDebianUpload(pu, repositories, options)
end

def processDebianUpload(debianUpload, repositories, options)
  # FIXME: nasty; we just pick the 1st distribution if none is
  # specified or if it doesn't match anything, because the
  # error-handling code is in Repository...
  rep = ( repositories[cfu.repository] or repositories.values[0] )
  rep.add(debianUpload, options[:email])
end

def processLocation(location, repositories, options)
  if File.directory?(location)
    Dir["#{location}/*.changes"].each { |file|
      processChangeFile(file, repositories, options)
    }

    Dir["#{location}/*.manifest"].each { |file|
      if File.file?(file.sub(/_\w.+\.manifest/, ".deb")) then
        # fine, the .deb file is also here...
        processManifestFile(file, repositories, options)
      else
        logger.debug("#{file} didn't have a corresponding .deb file alongside it.")
      end
    }
  else
    if location =~ /\.changes$/
      processChangeFile(location, repositories, options)
    elsif location =~ /\.manifest$/
      processManifestFile(location, repositories, options)
    else
      logger.error("#{location} is neither a manifest file nor a changes file, giving up.")
    end
  end
end

def parseCommandLineArgs(args)
  options = {}
  options[:daemonize] = false
  options[:moveFiles] = false
  options[:verbose]   = false
  options[:email]     = false

  opts = OptionParser.new do |opts|
    opts.on("-d", "--daemonize", "Daemonize the process") do |s|
      options[:daemonize] = true
    end
    opts.on("-m", "--move-files", "Move files after they're processed") do |s|
      options[:moveFiles] = true
    end
    opts.on("-v", "--verbose", "Turn on debug mode") do |s|
      options[:verbose] = true
    end
    opts.on("-e", "--email", "Turn on email notices") do |s|
      options[:email] = true
    end
    opts.on_tail("-h", "--help", "Show this usage statement") do |h|
      puts opts
    end
  end

  begin
    opts.parse!(args)
  rescue Exception => e
    puts e, "", opts
    exit
  end

  # location...
  location = ( args.length == 1 ) ? args[0] : INCOMING_DIR

  return location, options
end


# Main
begin
  location, options = parseCommandLineArgs(ARGV)

  # our logger
  logger = initializeLogging(options[:daemonize], options[:verbose])
  DebianUpload.logger = logger
  Distribution.logger = logger
  Repository.logger = logger

  # put all the repositories in a hash
  repositories = {}
  Dir["#{TOP_LEVEL_DIR}/*"].select { |d| File.directory?(d) }.each { |d|
    repositories[File.basename(d)] = Repository.new(d)
  }

  if options[:daemonize] then
    pid = fork do
      loop do
        begin
          logger.info("Daemon waking up")
          processLocation(location, repositories, options)
          logger.info("Daemon going to sleep for #{DELAY} seconds")
          sleep(DELAY)
        rescue Exception => e
          logger.error("#{e.class}: #{e.message}\n\t" + e.backtrace.join("\n\t"))
        end
      end
    end
    Process.detach(pid)
  else
    begin
      processLocation(location, repositories, options)
    rescue Exception => e
      logger.error("#{e.class}: #{e.message}\n\t" + e.backtrace.join("\n\t"))
    end
  end
end
