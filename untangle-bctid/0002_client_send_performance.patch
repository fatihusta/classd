diff -ur bcti-sdk-linux-5.27.2.orig/src/IsisSdkCore/SocketClient.cpp bcti-sdk-linux-5.27.2/src/IsisSdkCore/SocketClient.cpp
--- bcti-sdk-linux-5.27.2.orig/src/IsisSdkCore/SocketClient.cpp	2019-05-18 13:17:31.000000000 -0400
+++ bcti-sdk-linux-5.27.2/src/IsisSdkCore/SocketClient.cpp	2019-06-13 15:46:10.000000000 -0400
@@ -38,9 +38,10 @@
 		setsockopt(m_sock, IPPROTO_TCP, TCP_NODELAY, &optVal, sizeof optVal);
 //		setsockopt(m_sock, SOL_SOCKET, TCP_NODELAY, &optVal, sizeof optVal);
 		setsockopt(m_sock, SOL_SOCKET, SO_KEEPALIVE, &optVal, sizeof optVal);
+		setsockopt(m_sock, IPPROTO_TCP, TCP_CORK, &optVal, sizeof(optVal));
 
-		int flags = fcntl(m_sock, F_GETFL, 0);
-		fcntl(m_sock, F_SETFL, flags | O_NONBLOCK);
+		// int flags = fcntl(m_sock, F_GETFL, 0);
+		// fcntl(m_sock, F_SETFL, flags | O_NONBLOCK);
 
 		SetReceiveTimeout(1000);
 		SetConsecutiveTimeoutsSleepInterval(250);
@@ -80,15 +81,23 @@
 	if (!IsSocketValid())
 		return false;
 
+	int state = 0;
+
 	std::string msg(str);
-	if (appendEOT)
+	if (appendEOT){
+		setsockopt(m_sock, IPPROTO_TCP, TCP_CORK, &state, sizeof(state));
 		msg.append(m_eot);
+	}
 	size_t byteCount = msg.size();
 
 	if (m_timeSends)
 		m_sendTimer.start();
 	// Calls to send will block until the outgoing data buffer has sufficient space.
 	ssize_t result = send(m_sock, msg.c_str(), byteCount, MSG_NOSIGNAL);
+	if (appendEOT){
+		state = 1;
+		setsockopt(m_sock, IPPROTO_TCP, TCP_CORK, &state, sizeof(state));
+	}
 	if (m_timeSends)
 		m_sendTimer.pause();
 
