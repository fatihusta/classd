#!/bin/dash

run_command()
{
    local t_command_key
    local t_timeout
    local t_test_name
    local t_return_code
    local t_output
    local t_base
    
    ## dash doesn't have rand, but nanoseconds are just as good.
    t_command_key="command_`date +'%N'`"

    t_test_name=$1
    t_timeout=$2
    t_base="${OUTPUT_DIRECTORY}/${t_command_key}"
    t_return_code="${t_base}.ret"
    t_output="${t_base}.out"

    [ -z "${t_timeout}" ] && t_timeout=10

    t_timeout=$(( `date +"%s"` + ${t_timeout}))
    
    cat<<EOF > ${TEMP_COMMAND}
#!/bin/dash
EOF
    
    cat >> ${TEMP_COMMAND}
    
    echo "## 5640143ac40885c251e34e9a41de092c" >> ${TEMP_COMMAND}

    mkdir -p "${COMMAND_DIRECTORY}"
    cp ${TEMP_COMMAND} "${COMMAND_DIRECTORY}/${t_command_key}"

    while ( true ) ; do
        sleep .5
        
        if [ -f ${t_return_code} ] ; then
            break
        fi
        
        if [ `date +"%s"` -gt ${t_timeout} ]; then
            echo "timeout expired, unable to complete test ${t_test_name}"
            rm -f "${COMMAND_DIRECTORY}/${t_command_key}"
            rm -f ${t_base}.out ${t_base}.err ${t_base}.ret
            return 1
        fi
    done

    diff ${t_output} ${TEMP_EXPECTED} || {
        echo "Output files differ for ${t_test_name}"
        rm -f ${t_base}.out ${t_base}.err ${t_base}.ret
        return 1
    }

    echo "The test '${t_test_name}' passed"
    
    rm -f ${t_base}.out ${t_base}.err ${t_base}.ret
}


SHARED_DIRECTORY="/mnt/hgfs/untangle"

COMMAND_DIRECTORY="${SHARED_DIRECTORY}/commands"
OUTPUT_DIRECTORY="${SHARED_DIRECTORY}/logs"

TEMP_COMMAND=`mktemp`
TEMP_EXPECTED=`mktemp`

echo "Running a simple command to execute."
echo "This is a simple command" > ${TEMP_EXPECTED}
cat <<EOF | run_command simple 3
echo "This is a simple command"
EOF

rm -f ${TEMP_COMMAND} ${TEMP_EXPECTED}





