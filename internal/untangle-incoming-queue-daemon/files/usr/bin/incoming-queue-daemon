#! /usr/bin/ruby

# Sebastien Delafond <seb@untangle.com>

require 'optparse'
require 'log4r'
require 'untangle-reprepro.rb'

TOP_LEVEL_DIR = "/var/www/public"
INCOMING_DIR = "/var/www/untangle/incoming"
LOGFILE = "/var/log/untangle-incoming-queue-daemon.log"
DELAY = 60

def initializeLogging(logToFileOnly, verbose)
  log = Log4r::Logger.new("Untangle Incoming Queue Daemon")

  if logToFileOnly then
    fileFormat = Log4r::PatternFormatter.new(:pattern => "[ %d ] %l\t %m")
    log.add(Log4r::FileOutputter.new("fileOutputter", :filename => LOGFILE,
                                     :trunc => false, :formatter => fileFormat))
  else
    stdoutFormat = Log4r::PatternFormatter.new(:pattern => "%l:\t %m")
    log.add(Log4r::StdoutOutputter.new('stdout', :formatter => stdoutFormat))
  end

  log.level = verbose ? Log4r::DEBUG : Log4r::INFO
  
  return log
end


def processLocation(location, repositories, options)
  if File.directory?(location)
    Dir["#{location}/*.changes"].each { |file|
      cfu = ChangeFileUpload.new(file, options[:moveFiles])

      # FIXME: nasty; we just pick the 1st distribution if none is specified,
      # because the error-handling code is in Repository
      rep = ( repositories[cfu.distribution] or repositories.values[0] )
      rep.add(cfu)
    }

#     Dir["#{location}/*.deb"].each { |file|
#       if not File.file?(location + "/" + file.sub(/_.?\.deb/, ".dsc")) then
#         # we're good, this wasn't a source pkg upload taking too long to be uploaded...
#         pu = PackageUpload.new(file, options[:moveFiles])
#         pu.addToRepository
#       end
#     }
  else
    if location =~ /\.changes$/
      cfu = ChangeFileUpload.new(location, options[:moveFiles])
      # FIXME: nasty; we just pick the 1st distribution if none is specified,
      # because the error-handling code is in Repository
      rep = ( repositories[cfu.distribution] or repositories.values[0] )
      rep.add(cfu)
    else
#       pu = PackageUpload.new(location, options[:moveFiles])
#       pu.addToRepository
    end
  end
end

def parseCommandLineArgs(args)
  options = {}
  options[:daemonize] = false
  options[:moveFiles] = false
  options[:verbose]   = false
  options[:email]     = false

  opts = OptionParser.new do |opts|
    opts.on("-d", "--daemonize", "Daemonize the process") do |s|
      options[:daemonize] = true
    end
    opts.on("-m", "--move-files", "Move files after they're processed") do |s|
      options[:moveFiles] = true
    end
    opts.on("-v", "--verbose", "Turn on debug mode") do |s|
      options[:verbose] = true
    end
    opts.on("-e", "--email", "Turn on email notices") do |s|
      options[:email] = true
    end
    opts.on_tail("-h", "--help", "Show this usage statement") do |h|
      puts opts
    end
  end

  begin
    opts.parse!(args)
  rescue Exception => e
    puts e, "", opts
    exit
  end

  # location...
  location = ( args.length == 1 ) ? args[0] : INCOMING_DIR

  return location, options
end


# Main
begin
  location, options = parseCommandLineArgs(ARGV)

  # our logger
  logger = initializeLogging(options[:daemonize], options[:verbose])
  DebianUpload.logger = logger
  Distribution.logger = logger
  Repository.logger = logger

  # put all the repositories in a hash
  repositories = {}
  Dir["#{TOP_LEVEL_DIR}/*"].select { |d| File.directory?(d) }.each { |d|
    repositories[File.basename(d)] = Repository.new(d)
  }

  if options[:daemonize] then
    pid = fork do
      loop do
        begin
          processLocation(location, repositories, options)
          sleep(DELAY)
        rescue Exception => e
          logger.error("#{e.class}: #{e.message}\n\t" + e.backtrace.join("\n\t"))
        end
      end
    end
    Process.detach(pid)
  else
    begin
      processLocation(location, repositories, options)
    rescue Exception => e
      logger.error("#{e.class}: #{e.message}\n\t" + e.backtrace.join("\n\t"))
    end
  end
end
